import { Injectable, RequestMethod, Type } from '@nestjs/common';
import { DiscoveryService, MetadataScanner, Reflector } from '@nestjs/core';
import {
  Constructor,
  extractRouteParams,
  getProvisioneerProperties,
  GroupedPermission,
  ModuleProperties,
  Permission,
  LayoutRenderer,
  LayoutComponentDetail,
  PathProperties,
  Commissar,
  ProvisioneerProperties,
  LayoutRendererBuilder,
} from 'xingine';

import { METHOD_METADATA, PATH_METADATA } from '@nestjs/common/constants';
import { 
  getCommissarProperties, 
  getEnhancedCommissarProperties,
  getProvisioneerLayoutProperties,
  PROVISIONEER_LAYOUT_METADATA 
} from './xingine-nest.decorator';
import { extractMeta } from './utils/commissar.utils';
import { 
  CommissarOptions, 
  PathProperties as EnhancedPathProperties,
  ActionValidationResult 
} from './interfaces/layout-interfaces';
import { createDefaultLayout, createLoginLayout } from './templates/layout-templates';

@Injectable()
export class XingineInspectorService {
  constructor(
    private readonly discoveryService: DiscoveryService,
    private readonly metadataScanner: MetadataScanner,
    private readonly reflector: Reflector,
  ) {}

  /**
   * Get all layout renderers by scanning controllers with @Provisioneer decorators
   * Groups controllers by layout type and builds complete LayoutRenderer objects
   */
  getAllLayoutRenderers(): LayoutRenderer[] {
    const layoutRenderers: LayoutRenderer[] = [];
    const controllers = this.getAllControllers();

    // Group controllers by layout type from layoutMandate
    const layoutGroups = new Map<string, {
      provisioneerProperties: any;
      controllers: Constructor<unknown>[];
    }>();

    for (const controller of controllers) {
      // Try new format first
      const layoutProperties = getProvisioneerLayoutProperties(controller);
      const provisioneerProperties = getProvisioneerProperties(controller);
      
      if (!layoutProperties && !provisioneerProperties) continue;

      // Use layoutMandate from new format or fall back to old format
      const layoutType = layoutProperties?.type || 
                        provisioneerProperties?.layoutMandate?.type || 
                        provisioneerProperties?.layout || 
                        'default';

      if (!layoutGroups.has(layoutType)) {
        layoutGroups.set(layoutType, {
          provisioneerProperties: layoutProperties || provisioneerProperties,
          controllers: []
        });
      }
      layoutGroups.get(layoutType)!.controllers.push(controller);
    }

    // Build LayoutRenderer for each layout type
    for (const [layoutType, { provisioneerProperties, controllers }] of layoutGroups) {
      const commissarRoutes = this.extractCommissarRoutes(controllers);
      
      // Create base layout based on type
      let baseLayout: LayoutRenderer;
      if (layoutType === 'login') {
        baseLayout = createLoginLayout();
      } else {
        baseLayout = createDefaultLayout();
      }

      // Build enhanced layout renderer
      const layoutRenderer: LayoutRenderer = {
        type: layoutType,
        header: this.buildHeaderComponent(layoutType, controllers),
        sider: layoutType !== 'login' ? this.buildSiderComponent(layoutType, controllers) : undefined,
        content: {
          style: { className: 'layout-content' },
          meta: commissarRoutes
        },
        footer: this.buildFooterComponent(layoutType, controllers),
        style: {
          className: `layout-${layoutType}`,
          theme: layoutType === 'login' ? 'minimal' : 'default'
        }
      };

      layoutRenderers.push(layoutRenderer);
    }

    return layoutRenderers;
  }
    const modules = this.discoveryService.getProviders();

    return this.fetchMappedModules();
  }

  getAllControllerPath(): GroupedPermission {
    const allTheApis: GroupedPermission = {};
    const controllers = this.getAllControllers();
    for (const controller of controllers) {
      const controllerPath =
        this.reflector.get<string>(PATH_METADATA, controller) || '';

      const definedPaths: Permission[] = [];
      allTheApis[controllerPath] = definedPaths;

      const prototype = controller.prototype;

      const methodNames = Object.getOwnPropertyNames(prototype).filter(
        (name) =>
          typeof prototype[name] === 'function' && name !== 'constructor',
      );
      for (const methodName of methodNames) {
        const method = this.reflector.get<RequestMethod>(
          METHOD_METADATA,
          prototype[methodName],
        );

        if (!RequestMethod[method]) continue;

        const routePath = this.reflector.get<string | string[]>(
          PATH_METADATA,
          prototype[methodName],
        );
        const fullPath = (path: string) =>
          `${RequestMethod[method]}::/${controllerPath}/${path.replace(/^\//, '')}`;

        if (typeof routePath === 'string') {
          definedPaths.push({ name: fullPath(routePath), description: '' });
        }
        if (Array.isArray(routePath)) {
          for (const path of routePath) {
            definedPaths.push({ name: fullPath(path), description: '' });
          }
        }
      }
    }
    return allTheApis;
  }

  private getAllControllers(): Constructor<unknown>[] {
    return this.discoveryService
      .getControllers()
      .map((w) => w.metatype)
      .filter(
        (meta): meta is Constructor =>
          typeof meta === 'function' && !!meta.name,
      );
  }

  private fetchMappedModules(): ModuleProperties[] {
    const moduleProperties: ModuleProperties[] = [];

    const controllers = this.getAllControllers();

    for (const controller of controllers) {
      const provisioneerProperties = getProvisioneerProperties(controller);

      if (!provisioneerProperties) continue;

      const controllerPath =
        this.reflector.get<string>(PATH_METADATA, controller) || '';
      const prototype = controller.prototype;

      const mod: ModuleProperties = {
        name: provisioneerProperties.name!,
        uiComponent: [],
        permissions: [],
      };
      moduleProperties.push(mod);

      const methodNames = Object.getOwnPropertyNames(prototype).filter(
        (name) =>
          typeof prototype[name] === 'function' && name !== 'constructor',
      );

      for (const methodName of methodNames) {
        const commissar = getCommissarProperties(controller, methodName);
        if (!commissar) continue;

        const routePath = this.reflector.get<string>(
          PATH_METADATA,
          prototype[methodName],
        );
        const method = this.reflector.get<RequestMethod>(
          METHOD_METADATA,
          prototype[methodName],
        );
        let fullPath: string | undefined = undefined;
        let uiPath = `/${provisioneerProperties?.name}/${methodName}`;
        if (routePath !== undefined && method !== undefined) {
          const methodString = RequestMethod[method];
          fullPath = `/${controllerPath}/${routePath}`.replace(/\/+/g, '/');
          console.log(`[${methodString}] ${fullPath}`);
        }

        const slugs = extractRouteParams(fullPath ?? '');
        if (slugs.length >= 1) {
          uiPath += slugs.reduce((acc, key) => {
            return `${acc}/:${key}`;
          }, '');
        }

        /*const hasPermission = this.reflector.get(
            PERMISSION_GUARD_KEY,
            prototype[methodName],
        );

        if (hasPermission) {
          console.log(` ${controller.name}.${methodName} is annotated with @PermissionGateKeeper(${hasPermission})`);
        }*/

        const componentMeta = extractMeta(commissar, fullPath ?? '');

        const uiComponent = {
          component: commissar.component,
          layout: commissar.layout,
          path: uiPath,
          meta: componentMeta,
        };

        mod.uiComponent?.push(uiComponent);
      }
    }
    return moduleProperties;
  }

  /**
   * Extract commissar routes from controllers supporting both old and new formats
   */
  private extractCommissarRoutes(controllers: Constructor<unknown>[]): Commissar[] {
    const commissarRoutes: Commissar[] = [];
    
    for (const controller of controllers) {
      const controllerPath = this.reflector.get<string>(PATH_METADATA, controller) || '';
      const prototype = controller.prototype;
      const methodNames = Object.getOwnPropertyNames(prototype).filter(
        (name) => typeof prototype[name] === 'function' && name !== 'constructor'
      );

      for (const methodName of methodNames) {
        // Try enhanced commissar properties first, then fall back to old format
        const commissar = getEnhancedCommissarProperties(controller, methodName);
        if (!commissar) continue;

        // Check for layout override
        const pathConfig = 'path' in commissar ? commissar.path : commissar.layout;
        if (typeof pathConfig === 'object' && 'overrideLayout' in pathConfig && pathConfig.overrideLayout) {
          // Skip routes that override to different layouts for this layout group
          continue;
        }

        // Generate automatic path from controller + method routes
        const methodRoutePath = this.reflector.get<string>(PATH_METADATA, prototype[methodName]) || '';
        const autoGeneratedPath = `/${controllerPath}/${methodRoutePath}`.replace(/\/+/g, '/');
        
        // Determine final path
        let finalPath: string;
        if ('path' in commissar) {
          // New format
          finalPath = typeof commissar.path === 'string' 
            ? commissar.path 
            : (typeof commissar.path === 'object' && commissar.path?.path) 
              ? commissar.path.path 
              : autoGeneratedPath;
        } else {
          // Old format fallback
          finalPath = autoGeneratedPath;
        }

        // Get component definition
        let component: LayoutComponentDetail | undefined;
        if ('component' in commissar && commissar.component) {
          // New format - component is directly provided
          component = commissar.component;
        } else {
          // Old format - extract from method or commissar properties
          const legacyCommissar = commissar as any;
          component = legacyCommissar.component;
        }

        if (!component) {
          console.warn(`Warning: ${controller.name}.${methodName} @Commissar decorator missing component definition`);
          continue;
        }

        // Validate action methods for new format
        if ('preAction' in commissar || 'postAction' in commissar) {
          const actionValidation = this.validateCommissarActions(controller, commissar as CommissarOptions);
          if (!actionValidation.preActionValid || !actionValidation.postActionValid) {
            console.error(`Error: ${controller.name}.${methodName} has invalid action references`);
            continue;
          }
        }

        // Build final commissar route
        const route: Commissar = {
          path: finalPath,
          component: component,
          meta: {
            controllerName: controller.name,
            methodName: methodName,
            preAction: 'preAction' in commissar ? commissar.preAction : undefined,
            postAction: 'postAction' in commissar ? commissar.postAction : undefined,
            permissions: commissar.permissions || [],
            hasPreAction: 'preAction' in commissar && !!commissar.preAction,
            hasPostAction: 'postAction' in commissar && !!commissar.postAction
          },
          isMenuItem: this.getIsMenuItem(pathConfig),
          icon: this.getIcon(pathConfig),
          label: this.getLabel(pathConfig, methodName)
        };

        commissarRoutes.push(route);
      }
    }
    
    return commissarRoutes;
  }

  /**
   * Validate that preAction and postAction methods exist on controller
   */
  private validateCommissarActions(
    controller: Constructor<unknown>, 
    commissar: CommissarOptions
  ): ActionValidationResult {
    const prototype = controller.prototype;
    
    const preActionValid = !commissar.preAction || 
      (typeof prototype[commissar.preAction] === 'function');
      
    const postActionValid = !commissar.postAction || 
      (typeof prototype[commissar.postAction] === 'function');

    const errors: string[] = [];
    
    if (!preActionValid) {
      errors.push(`Missing preAction method: ${commissar.preAction}`);
    }
    
    if (!postActionValid) {
      errors.push(`Missing postAction method: ${commissar.postAction}`);
    }

    return { 
      preActionValid, 
      postActionValid, 
      errors: errors.length > 0 ? errors : undefined 
    };
  }

  /**
   * Build header component for layout type
   */
  private buildHeaderComponent(layoutType: string, controllers: Constructor<unknown>[]): { style?: any; meta?: LayoutComponentDetail } {
    // Get base template
    const baseLayout = layoutType === 'login' ? createLoginLayout() : createDefaultLayout();
    return baseLayout.header || { style: { className: 'layout-header' } };
  }

  /**
   * Build sider component for layout type
   */
  private buildSiderComponent(layoutType: string, controllers: Constructor<unknown>[]): { style?: any; meta?: LayoutComponentDetail } {
    // Get base template
    const baseLayout = createDefaultLayout();
    return baseLayout.sider || { style: { className: 'layout-sider' } };
  }

  /**
   * Build footer component for layout type
   */
  private buildFooterComponent(layoutType: string, controllers: Constructor<unknown>[]): { style?: any; meta?: LayoutComponentDetail } {
    // Get base template
    const baseLayout = layoutType === 'login' ? createLoginLayout() : createDefaultLayout();
    return baseLayout.footer || { style: { className: 'layout-footer' } };
  }

  /**
   * Extract isMenuItem from path configuration
   */
  private getIsMenuItem(pathConfig: any): boolean {
    if (typeof pathConfig === 'object' && 'isMenuItem' in pathConfig) {
      return pathConfig.isMenuItem !== false;
    }
    return true; // Default to true
  }

  /**
   * Extract icon from path configuration
   */
  private getIcon(pathConfig: any): any {
    if (typeof pathConfig === 'object' && 'icon' in pathConfig) {
      return pathConfig.icon;
    }
    return undefined;
  }

  /**
   * Extract or generate label from path configuration or method name
   */
  private getLabel(pathConfig: any, methodName: string): string {
    if (typeof pathConfig === 'object' && 'label' in pathConfig && pathConfig.label) {
      return pathConfig.label;
    }
    return this.generateLabelFromMethodName(methodName);
  }

  /**
   * Generate human-readable label from method name
   */
  private generateLabelFromMethodName(methodName: string): string {
    // Convert camelCase to readable label
    // getUserDashboard -> Get User Dashboard
    return methodName
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .trim();
  }

  getAllModuleProperties(): ModuleProperties[] {
}
